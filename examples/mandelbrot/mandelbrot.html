<html>
  <head>
    <title>MandelMap</title>
    <script type="text/javascript" src="../../polymaps.js"></script>
    <style type="text/css">

@import url("../example.css");

#map {
  background: #ddd;
}

    </style>
  </head>
  <body id="map">
    <script type="text/javascript">

var po = org.polymaps;

var map = po.map()
    .container(document.getElementById("map").appendChild(po.svg("svg")))
    .zoomRange([0, 20])
    .zoom(2)
    .center({lat: 0, lon: 0})
    .add(po.interact());

map.add(po.layer(canvas));
//    .zoom(4));

map.add(po.compass()
    .pan("none"));

function canvas(tile) {
  if (tile.column < 0 || tile.column >= (1 << tile.zoom)) {
    tile.element = po.svg("g");
    return; // no wrap
  }

  var size = map.tileSize(),
      o = tile.element = po.svg("foreignObject"),
      c = o.appendChild(document.createElement("canvas")),
      g = c.getContext("2d"),
      image = g.createImageData(size.x, size.y);

  o.setAttribute("width", size.x);
  o.setAttribute("height", size.y);
  c.setAttribute("width", size.x);
  c.setAttribute("height", size.y);
  g.fillRect(0, 0, size.x, size.y);

  // following code adapted blindly from http://blogs.msdn.com/mikeormond/archive/2008/08/22/deep-zoom-multiscaletilesource-and-the-mandelbrot-set.aspx

  var tileCountX = Math.pow(2, tile.zoom);
  var tileCountY = Math.pow(2, tile.zoom);

  tileCountX = tileCountX < 1 ? 1 : tileCountX;
  tileCountY = tileCountY < 1 ? 1 : tileCountY;        

  var ReStart = -2.0;
  var ReDiff = 3.0;

  var MinRe = ReStart + ReDiff * tile.column / tileCountX;
  var MaxRe = MinRe + ReDiff / tileCountX;

  var ImStart = -1.2;
  var ImDiff = 2.4;

  var MinIm = ImStart + ImDiff * tile.row / tileCountY;
  var MaxIm = MinIm + ImDiff / tileCountY;

  var Re_factor = (MaxRe - MinRe) / (size.x - 1);
  var Im_factor = (MaxIm - MinIm) / (size.y - 1);

  var MaxIterations = 32;

  for (var y = 0; y < size.y; ++y) {
    var c_im = MinIm + y * Im_factor;
    for (var x = 0; x < size.x; ++x) {
      var c_re = MinRe + x * Re_factor;
      var Z_re = c_re;
      var Z_im = c_im;
      var isInside = true;
      var n = 0;
      for (n = 0; n < MaxIterations; ++n) {
        var Z_re2 = Z_re * Z_re;
        var Z_im2 = Z_im * Z_im;
        if (Z_re2 + Z_im2 > 4) {
          isInside = false;
          break;
        }
        Z_im = 2 * Z_re * Z_im + c_im;
        Z_re = Z_re2 - Z_im2 + c_re;
      }
      if (isInside) {
        var index = 4 * ((y * size.x) + x);
        image.data[index] = image.data[index+1] = image.data[index+2] = 0;
        image.data[index+3] = 255;
      }
      else {
        if (n < MaxIterations / 2) {
          var index = 4 * ((y * size.x) + x);
          image.data[index] = 255 / (MaxIterations / 2) * n;
          image.data[index+1] = 0;
          image.data[index+2] = 0;
          image.data[index+3] = 255;
        }
        else {
          var index = 4 * ((y * size.x) + x);
          image.data[index] = 255;
          image.data[index+1] = (n - MaxIterations / 2) * 255 / (MaxIterations / 2);
          image.data[index+2] = (n - MaxIterations / 2) * 255 / (MaxIterations / 2);
          image.data[index+3] = 255;
        }
      }
    }
  }
  g.putImageData(image, 0, 0);
}

    </script>
  </body>
</html>
